# 학습 목표
* 언리얼 환경에서 알아두어야 할 기본 타입과 고려할 점
* 캐릭터 인코딩 시스템에 대한 이해
* 언리얼 C++이 제공하는 다양한 문자열 처리 방법과 내부 구성의 이해

---

# 언리얼 C++ 기본 타입 

## 🔥왜 언리얼은 기본 타입을 따로 지정하는가?
***언리얼은 C++의 기본 타입을 사용하지 않는다.***

우리가 많이 사용하는 `int`의 경우에는 C++ 최신 규약에서는 최소 32비트를 보장하도록 규정되어 있다.
이를 다르게 말하면, 어떤 플랫폼에서는 `int`형이 64비트로 해석될 수가 있다는 뜻이다.

따라서 int형으로 선언된 변수를 저장할 때는 `int` 타입의 크기를 확신할 수가 없다는 것이 문제이다.

이것은 게임 제작에 있어서 치명적인 문제를 가져올 수 있다.
왜냐하면 게임 제작의 경우에는 다른 프로그램 제작과 다르게 단일 컴퓨터에서 퍼포먼스를 최대치로 뽑아내야 되는 것이 목적이기 때문이다.

그렇기 위해서는, 캐시 히트율 같은 것들을 신경 써서 자료구조를 만들고, 데이터를 저장해야 한다.
즉, 캐시 히트율을 높이는 것과 같은 효율성을 높이기 위해서는 데이터 정보가 캐시 크기에 맞춰서 잘 정렬되어야 한다.

그렇기 때문에 애매모호한 크기를 가지는 타입들을 사용하는 것이 게임 제작에 있어서 영향을 미칠 수가 있다.

또한 멀티 플레이어로 확장해서 생각을 해보면 네트워크상에서 주고받는 데이터 통신이 효율적이고 안정적이어야 되는데, 
그러기 위해서는 데이터의 정보가 명확해야 한다.

그렇기 때문에 애매모호한 데이터 타입은 게임 개발 시 성능을 저하시키고 문제를 일으킬 수가 있다.

이러한 문제를 인식한 후발 객체지향 언어(C#과 같은..)의 경우는 `int`타입이 있지만 4바이트인 `int32`로 명확히 정의되어 있다.
언리얼은 `int`를 사용하지 않고 `int32`를 사용한다.

## 🔥언리얼 엔진의 타입과 크기
![image](https://github.com/SunFlower2819/Today-I-learned/assets/130738283/1da78053-d0c0-4912-b44a-960499822c47)

## 🔥bool 타입의 선언
`bool` 타입의 경우에는 크기가 명확하지 않다.

이러한 참과 거짓의 데이터를 네트워크를 통해서 전송한다던가, 디스크에 파일로 저장할 때
이것을 어떻게 할지가 정확히 명시되어 있지 않다.

그래서 `bool`형 같은 경우에는 데이터를 저장하는데 선언되는 헤더 파일, 클래스 헤더의 멤버 변수(member variable)같은 헤더 파일에는 
`bool`이라는 데이터 타입을 사용하지 않고, 대신에 바이트 정보를 사용한다.

그런데 참과 거짓을 저장하는데 있어서 바이트를 사용하면 너무 데이터의 양이 많기 때문에 `Bit Field`라는 오퍼레이터를 사용해서
데이터의 크기를 제한시킬 수가 있다.

그래서, 이러한 `bool` 타입을 저장할 때에는 우리가 이 바이트 타입인 `uint8`을 사용해가지고 변수를 선언하되,
`Bit Field` 오퍼레이터를 1비트로 선언해가지고 데이터 양을 최소화시킬 수가 있다.

이렇게 1비트만을 사용해서 참과 거짓 데이터를 저장하는 `int8`,`uint8`의 경우에는 일반 `uint8`변수와 구분하기 위해서 
앞에 접두사 `b`를 붙이도록 코딩 표준에 명시가 되어 있다. 

하지만 이것은 데이터를 저장하는 데 있어서 고려사항이기 때문에, 우리가 헤더가 아닌 Cpp 파일의 로직에서 `bool` 타입을 사용할 때는
굳이 비트 플래그를 명시하거나, `uint`타입을 사용하지 않고, 자유롭게 `bool`을 사용해도 무방하다. --> ✅난 이 문장이 이해가 잘 안된다. (Cpp 파일에서는 `bool`을 사용해도 무방하다는 뜻인가?

![image](https://github.com/SunFlower2819/Today-I-learned/assets/130738283/993ef11f-df95-432f-8930-19f8911b6052)


* 데이터 전송을 고려한 참/거짓 데이터의 지정
* `bool`은 크기가 명확하지 않음
* 헤더에는 가급적 `bool` 대신 `unit8` 타입을 사용하되 `Bit Field` 오퍼레이터를 사용
* 일반 uint8과의 구분을 위해 `b`접두사를 사용.
* Cpp 로직에서는 자유롭게 `bool`을 사용

---

# 캐릭터 인코딩
언리얼의 경우에는 `int`와 마찬가지로 문자열을 지정하기 위해서 `TCHAR`이라고 하는 별도의 타입을 지정해서 사용하도록
코딩 규칙이 지정되어 있다.

***왜 언리얼은 문자열을 따로 지정하고 있을까?***

영어 같은 경우에는 1byte로 충분히 표현이 가능하다. 하지만 한국, 중국, 일본같은 동아시아 국가에 컴퓨터가 들어오게 되면서
이들 나라의 문자를 1byte로 표현할 수 없기 때문에 새로운 규약이 필요했다.

지금은 Unicode에 정착이 됐지만 Unicode가 나오기 이전에는 Multibyte 문자열 체계가 사용되었다. 
문제는 아직도 윈도우즈 운영체제에는 Multibyte 문자열 체계가 널리 쓰이고 있다는 것이다.

그렇기 때문에 우리가 처리해야할 문자열의 종류가 총 세가지가 있다는 뜻이된다.

* Single byte(ANSI, ASCII) : 컴퓨터 초창기
* Multibyte(EUC-KR, CP949) : 컴퓨터 보급기 (1990년대 초중반)
* Unicode(UTF-8, UTF-16) : 국제 표준 정착기 (1990년대 후반)

그렇기에 언리얼은 이렇게 복잡한 상황을 심플하게 하기 위해서 `TCHAR`라는 문자열 고유한 처리 방식을 제공하고 있다. 
따라서 우리는 세 가지 타입에 대해서 신경 쓸 필요 없이 `TCHAR`하나만 가지고 문자열을 처리해주면 된다.

> **📌캐릭터 인코딩에 관련한 공식 문서(읽어볼 것!)** <br>
> https://dev.epicgames.com/documentation/ko-kr/unreal-engine/character-encoding-in-unreal-engine?application_version=5.1
> <br>
> 정리하자면, 스트링을 관리하는데 있어서 UTF-16을 사용하고, 소스코드에 꼭 한글을 사용하겠다고 하면 UTF-8 방식으로 저장하면 된다.
> 하지만 여러 가지 문제가 발생할 수 있으므로, 잘 알아보고 해라.

---

# TCHAR와 FString 

우선 `TCHAR`배열 사용해서 문자열을 출력해보겠다.
```cpp
// MyGameInstance.cpp
#include "MyGameInstance.h"

void UMyGameInstance::Init()
{
	Super::Init(); 

	TCHAR LogCharArray[] = TEXT("Hello Unreal!!"); 
	UE_LOG(LogTemp, Log, TEXT("%s"), LogCharArray);
}
```
![image](https://github.com/SunFlower2819/Today-I-learned/assets/130738283/c5b103f2-8e9d-4939-b3b7-44085be5f7ab)


<br>

만약에 문자열을 다양하게 조작하고 싶다면, `TCHAR` 배열을 사용하는 것이 아니고 언리얼 엔진에서 제공하고 있는 `FString` 클래스를 사용해야 한다. 
```cpp
// MyGameInstance.cpp
#include "MyGameInstance.h"

void UMyGameInstance::Init()
{
	Super::Init();

	TCHAR LogCharArray[] = TEXT("Hello Unreal!!");
	UE_LOG(LogTemp, Log, TEXT("%s"), LogCharArray);

	FString LogCharString = LogCharArray; // TCHAR문자열을 대입만 해주면 자동으로 FString 안쪽에 데이터들이 포함된다.
	UE_LOG(LogTemp, Log, TEXT("%s"), *LogCharString); // 🎈🎈꼭 포인터 연산자를 써줘야 한다!!

	// 반드시 포인터 연산자를 써줘야 FString이 감싸고 있는 문자열 데이터를 가져올 수가 있다.
}
```
![image](https://github.com/SunFlower2819/Today-I-learned/assets/130738283/ec2cc292-3caf-4d16-b2a5-a6825ace31c5)

<br>

***언리얼에서는 복잡한 문자의 처리를 UTF-16을 사용해서 하나로 통일된다.
각각의 문자열은 `TCHAR`라고 하는 언리얼이 지정한 이 캐릭터 타입을 사용해야 한다.***

그리고 문자열은 언제나 `TEXT` 매크로를 사용해서 지정을 해줘야 하는데,
`TEXT`매크로는 2바이트 UTF-16 문자열로 내부에서 반환시킨다.

이러한 문자열을 다루는 클래스로 `FString`을 제공한다.

* 유니코드를 사용해 문자열 처리를 통일
  - 이 중에서 2byte로 사이즈가 균일한 UTF-16을 사용
  - 유니코드를 위한 언리얼 표준 캐릭터 타입: `TCHAR`
* 문자열은 언제나 `TEXT` 매크로를 사용해 지정
  - `TEXT` 매크로로 감싼 문자열은 `TCHAR` 배열로 지정됨
* 문자열을 다루는 클래스로 `FString`을 제공함
  - `FString`은 `TCHAR` 배열을 포함하는 헬퍼 클래스

<br>

추가적으로 아래와 같은 코드도 작성이 가능하다.
```cpp
#include "MyGameInstance.h"

void UMyGameInstance::Init()
{
	Super::Init(); 

	FString LogCharString = TEXT("UTF-16");
	UE_LOG(LogTemp, Log, TEXT("%s"), *LogCharString);
}

```
![image](https://github.com/SunFlower2819/Today-I-learned/assets/130738283/dd27ff9f-c088-4e26-9fba-bd55c0cb976d)

## 🔥FString의 구조와 활용
> 📌**FString 문서** <br>
> https://dev.epicgames.com/documentation/ko-kr/unreal-engine/fstring-in-unreal-engine?application_version=5.1
<br>

`TEXT("Hello")`를 선언하게 되면 `TCHAR`배열로 만들어지게 된다.
이 `TCHAR`배열을 `FString` 집어넣으면 언리얼 엔진이 제공하는 동적 배열 클래스인 `TArray` 방식으로 "Hello"라는 문자열이 보관된다.

즉, `FString`에 포함하고 있는 동적 배열, `TArray`에 포함되어 있는 첫 번째 인자의 포인터를 `*`연산자를 사용해서 반환해준다. 

`FString` 자체적으로 다양한 기능을 제공하고 있기 때문에 데이터들을 여러가지로 자르거나, 붙이거나, 새로운 방식으로 불러들이거나, 다양한 연산을 할 수가 있다.

그리고 `FString`이 제공하는 함수들 내부적으로 `FCString`이라는 클래스가 있다. `FCString` 클래스는 일종의 C 라이브러에서 제공하는 
기본적인 스트링 관련 함수들을 포함하고 있는 래퍼 클래스(Wrapper Class)라고 생각하면 된다.

고로 `FString`은 데이터를 보관하지만 실제로 문자열을 찾거나 자르거나하는 처리들은  `FCString`을 통해서 진행한다.

![image](https://github.com/SunFlower2819/Today-I-learned/assets/130738283/0ba1904a-17b3-4e94-8c2a-13c41656dac0)

* 다른 타입에서 `FString`으로의 변환
  * `FString::Printf`
  * `FString::SanitizeFloat`
  * `FString::FromInt`
* C런타임 수준에서 문자열을 처리하는 클래스 `FCString`
  * 예) 문자열을 찾는 `strstr`을 사용
* FString에서 다른 타입으로의 변환 (안전하진 않으므로 주의)
  * `FCString::Atoi`
  * `FCString::Atof`
















